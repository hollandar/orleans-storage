@using Cadence.UI.Components
@using System.Text.Json
@using Webefinity.Module.Blocks.Abstractions
@using Webefinity.Module.Blocks.Services

<HeadContent>
    <link rel="stylesheet" href="@Assets["_content/Webefinity.Module.Blocks/css/blocks_page.css"]" />
</HeadContent>

@if (pageModel is not null)
{
    <PageTitle>@this.pageModel.Title</PageTitle>
    @foreach (var enumBlockState in this.blockEditorStates)
    {
        var blockState = enumBlockState;
        var blockModel = blockState.Model;
        var hasBlock = BlockProvider.HasBlock(blockModel.Kind);

        <div @key="blockState.Id">
            @if (hasBlock.block)
            {
                <div class="blocks-container @(blockState.Editing? "editing": "viewing")" data-blockid="@blockModel.Id" data-blockkind="@blockModel.Kind" data-blocksequence="@blockModel.Sequence">
                    <div class="blocks-block">
                        <div>
                            @BlockProvider.RenderFragment(blockModel)
                        </div>
                        @if (Edit)
                        {
                            if (!blockState.Editing) {
                                <div class="blocks-blockbar stack horizontal" style="--stack-gap: 0.25rem;">
                                    @if (hasBlock.editor)
                                    {
                                        <Button class="control" Clicked="async () => await SetEditing(blockState)"><Icon><i class="fa-solid fa-pencil fa-xs"></i></Icon></Button>
                                    }
                                    <button class="button control"><i class="fa-solid fa-trash fa-xs"></i></button>
                                </div>
                            }
                            else
                            {
                                // Nada
                            }
                        }
                    </div>
                    @if (Edit && blockState.Editing)
                    {
                        <div class="blocks-editor">
                            @BlockProvider.RenderEditorFragment(blockModel, BuildApply(blockState), BuildSave(blockState), BuildCancel(blockState))
                        </div>
                    }
                </div>
            }
            else
            {
                <div class="block-missing">
                    Block missing: @blockModel.Kind
                </div>
            }
        </div>
    }
}
else
{
    <PageTitle>Page not found</PageTitle>
    <p>Page not found</p>
}

@code {
    [Inject] public BlocksProviderService BlocksProvider { get; set; } = default!;
    [Inject] internal BlockProviderService BlockProvider { get; set; } = default!;
    [Parameter] public bool Edit { get; set; } = false;
    [Parameter] public string PageName { get; set; } = default!;

    bool exists = false;
    PageModel pageModel = default!;
    IEnumerable<BlockEditorState> blockEditorStates = Array.Empty<BlockEditorState>();

    class BlockEditorState(BlockModel model)
    {
        public Guid Id { get; set; } = Guid.NewGuid();
        public bool Editing { get; set; } = false;
        public BlockModel Model { get; set; } = model;
    }

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();

        this.exists = await BlocksProvider.PageExistsAsync(PageName, CancellationToken.None);
        if (!this.exists) return;

        this.pageModel = await BlocksProvider.GetPageModelAsync(PageName, CancellationToken.None);
        this.blockEditorStates = this.pageModel.Blocks.Select(m => new BlockEditorState(m)).ToList().OrderBy(r => r.Model.Sequence);
    }

    async Task SetEditing(BlockEditorState blockEditorState)
    {
        if (!this.Edit)
        {
            throw new InvalidOperationException("Cannot edit block when not in edit mode");
        }

        blockEditorState.Editing = true;
        await InvokeAsync(StateHasChanged);
    }

    async Task SetViewing(BlockEditorState blockEditorState)
    {
        blockEditorState.Editing = false;
        await InvokeAsync(StateHasChanged); 
    }

    EventCallback<JsonDocument> BuildApply(BlockEditorState blockState) => EventCallback.Factory.Create<JsonDocument>(blockState, async (doc) => await ApplyBlockDocumentAsync(blockState, doc));
    EventCallback<JsonDocument> BuildSave(BlockEditorState blockState) => EventCallback.Factory.Create<JsonDocument>(blockState, async (doc) => await SaveBlockDocumentAsync(blockState, doc));

    EventCallback BuildCancel(BlockEditorState blockState) => EventCallback.Factory.Create(this, () => this.SetViewing(blockState));

    async Task ApplyBlockDocumentAsync(BlockEditorState blockState, JsonDocument doc)
    {
        var saved = await BlocksProvider.SetBlockModelAsync(blockState.Model, doc, CancellationToken.None);
        if (!saved) throw new InvalidOperationException("Could not save");
        if (saved)
        {
            blockState.Model.Data = doc;
        }
        await this.InvokeAsync(StateHasChanged);
    }
    
    async Task SaveBlockDocumentAsync(BlockEditorState blockState, JsonDocument doc)
    {
        var saved = await BlocksProvider.SetBlockModelAsync(blockState.Model, doc, CancellationToken.None);
        if (!saved) throw new InvalidOperationException("Could not save");
        if (saved)
        {
            blockState.Model.Data = doc;
        }

        await SetViewing(blockState);
    }
}